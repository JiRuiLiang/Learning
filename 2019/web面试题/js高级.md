1. 全局函数eval()有什么作用？
  - eval可以将字符串生成语句执行
  - 这个函数可以把一个字符串当作一个JavaScript表达式一样去执行它

2. 请介绍一下DocumentFragment类型的节点。
  - 文档片段接口，表示一个没有父级文件的最小文档对象。它被作为一个轻量版的 Document 使用，用于存储已排好版的或尚未打理好格式的XML片段。最大的区别是因为 DocumentFragment 不是真实DOM树的一部分，它的变化不会触发 DOM 树的（重新渲染) ，且不会导致性能等问题。

3. 执行a == 1 && a == 2 && a == 3，返回的结果是true，那么a的值是什么？
  ```js
  var a = {
    i: 1,
    toString () {
      return a.i++
    }
  }
  ```

4. 如何判断对象中的某个属性是继承而来的？ `hasOwnProperty`

5. 事件传播的三个阶段
  - 第一阶段：从window对象传导到目标节点，称为“捕获阶段”（capture phase）。
  - 第二阶段：在目标节点上触发，称为“目标阶段”（target phase）。
  - 第三阶段：从目标节点传导回window对象，称为“冒泡阶段”（bubbling phase）。

6. 为什么闭包会产生内存泄漏？？
  - 外部函数声明内部函数，内部函数引用外部函数的局部变量，这些变量不会被释放！

7. bind，call，apply三个函数
  - 这三个函数都用来重新定义this指向
  ```js
    var name = '王华', age = 17;
    var obj = {
      name = '潘明'，
      objAge: this.age,
      myFun: function () {
        console.log(this.name + '年龄' + this.age)
      }
    }
    var db = {
      name: '秦奋',
      age: 99
    }

    obj.muFun.call(db) // 德玛年龄99
    obj.muFun.apply(db) // 德玛年龄99
    obj.muFun.bind(db)() // 德玛年龄99
  ```
  - bind 返回的是一个新的函数，你必须调用它才会被执行
  - 异同
    + `call 、bind 、 apply` 这三个函数的第一个参数都是 this 的指向对象，第二个参数差别就来了：
    + `call`的参数是直接放进去的，第二第三第n个参数全都用逗号分隔，直接放到后面,`obj.myFun.call(db,'成都', ... ,'string' )`;
    + `apply`的所有参数都必须放在一个数组里面传进去, `obj.myFun.apply(db,['成都', ..., 'string' ])`;
    + `bind`除了返回是函数以外，它 的参数和`call` 一样。

8. 前端的requestAnimationFrame了解？使用场景？
  - 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行

9. 不用循环语句（for、while等）创建一个长度为50的数组，每个元素的值等于它的索引。
  - `(new Array(50)).fill(0).map((n, i) => i)`

10. 有一个数组，其值为[1,[2,[3,4,2],2],5,[6]]，如何才能输出[1,2,3,4,2,2,5,6]？
  ```js
    function oneDimensionalArray (arr) {
      let arr1 = (arr + '').split(','); // 将数组转字符串后再以逗号分隔转为数组
      let arr2 = arr1.map(function(x){
        return Number(x);
      });
      return arr2;
    }
  ```

12. 字符串和new String出来的字符串有啥区别？
  - 直接赋值只是设置变量
  - 通过new String() 是声明成员，定义属性

13. 递归和迭代的区别是什么，各有什么优缺点？
  - 定义
    + 程序调用自身称为递归。
    + 利用变量的原值推出新值称为迭代。
  - 优缺点
    + 递归
      - 优点：大问题转化为小问题，可以减少代码量，同时代码精简，可读性好；
      - 缺点：就是递归调用浪费了空间，而且递归太深容易造成堆栈的溢出。
    + 迭代
      - 优点：代码运行效率好，因为时间只因循环次数增加而增加，而且没有额外的空间开销；
      - 缺点：代码不如递归简洁

14. 什么是节流和抖动？
  - 节流：规定函数在某时间段内最多执行一次
  - 抖动：函数防抖: 防止函数执行过快,在连续执行的时候卡住

15. 什么是Promise？
  - Promise对象用于表示一个异步操作的最终状态（完成或失败），以及该异步操作的结果值。

16. Promise包含几种状态？
  - pending: 初始状态，既不是成功，也不是失败状态。
  - fulfilled: 意味着操作成功完成。
  - rejected: 意味着操作失败

17. 箭头函数和普通函数有什么区别？
  - 箭头函数
    + 箭头函数没有自己的this,继承的是外层代码块的this。
    + 不可以当做构造函数，也就是说不可以使用new命令，否则会报错的。
    + 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
    + 不可以使用yield命令，因此箭头函数不能用作 Generator（生成器） 函数。
    + 因为没有this,所以不能使用call、bind、apply来改变this的指向。

18. AMD与CMD的区别有哪些？
  - AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。
  - CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。
  - 区别
    + 对于依赖的模块，AMD是提前执行，CMD是延迟执行。（RequireJS2.0开始，AMD也可改为延迟执行）。CMD 推崇 as lazy as possible
    + CMD推崇依赖就近，AMD推崇依赖前置
    + AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。

19. 依赖注入的原理什么？如何实现一个简单的依赖注入？
  - 依赖注入是用于实现控制反转的一种方式（控制反转用于解耦）
  - 原理：声明实例并通过`constructor`注入

20. 什么是进程？什么是线程？
  - 进程是系统中正在运行的一个程序，程序一旦运行就是进程。
  - 一个进程可以有多个线程，线程就是其所属进程的栈空间。

21. 进程和线程的区别？
  - 地址空间和其他资源（如打开文件）：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其他进程内不可见。
  - 通信：进程间通信IPC（管道，信号量，共享内存，消息队列），线程间可以直接独写进程数据段（如全局变量）来进程通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。
  - 调度和切换：线程上下文切换比进程上下文切换快得多。
  - 在多线程OS中，进程不是一个可执行的实体。

22. 如何选择进程及线程？
  - 需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程的代价是很大的。
  - 线程的切换速度快，所以在需要大量计算，切换频繁时使用线程，还有耗时的操作时用使用线程可提高应用程序的响应。
  - 因为对CPU系统的效率使用上线程更占优势，所以可能要发展到多机分布的用进程，多核分布用线程。
  - 并行操作时用线程，如C/S架构的服务器端并发线程响应用户的请求。
  - 需要更稳定安全时，适合选择进程；需要速度时，选择线程更好。

23. 前端渲染与后端渲染相比，有哪些优缺点？
  - 前端渲染 > 指的是后端返回JSON数据，前端利用预先写的html模板，循环读取JSON数据，拼接字符串（es6的模板字符串特性大大减少了拼接字符串的的成本），并插入页面。
    + 好处： 网络传输数据量小。不占用服务端运算资源（解析模板），模板在前端（很有可能仅部分在前端），改结构变交互都前端自己来了，改完自己调就行。
    + 坏处： 前端耗时较多，对前端工作人员水平要求相对较高。前端代码较多，因为部分以前在后台处理的交互逻辑交给了前端处理。占用少部分客户端运算资源用于解析模板。
  - 后端渲染 > 前端请求，后端用后台模板引擎直接生成html，前端接受到数据之后，直接插入页面。
    + 好处：前端耗时少，即减少了首屏时间，模板统一在后端。前端（相对）省事，不占用客户端运算资源（解析模板）
    + 占用服务器资源。

24. JavaScript中的原型及原型链

25. JavaScript中的闭包

36. JavaScript中的额继承
